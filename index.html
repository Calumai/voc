<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>小寶貝5.0 (v1.0 Classic)</title>
    
    <!-- 載入 Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- 載入 Babel -->
    <script src="https://unpkg.com/@babel/standalone@7.23.6/babel.min.js"></script>

    <!-- 載入 JSZip -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>

    <style>
        .custom-scrollbar::-webkit-scrollbar {
            height: 10px;
            width: 8px;
            background-color: #0f172a;
        }
        .custom-scrollbar::-webkit-scrollbar-thumb {
            background-color: #334155;
            border-radius: 5px;
            border: 2px solid #0f172a;
        }
        .custom-scrollbar::-webkit-scrollbar-thumb:hover {
            background-color: #475569;
        }
        body {
            background-color: #0f172a; 
            color: #f1f5f9;
        }
        .no-select {
            user-select: none;
            -webkit-user-select: none;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel" data-type="module" data-presets="react">
        import React, { useState, useRef, useEffect, useMemo, useCallback } from 'https://esm.sh/react@18.2.0';
        import ReactDOM from 'https://esm.sh/react-dom@18.2.0/client';
        import { Upload, Download, Settings, Play, Pause, RefreshCw, Mic, Users, AlertCircle, FileAudio, Scissors, FileSpreadsheet, ZoomIn, Activity, Package, Trash2, Gauge, BrainCircuit, Wand2, Layers, CheckCircle2, XCircle, FileMusic, ArrowRight, Merge, Link2, Link2Off, Move, Plus, MousePointer2, MessageSquare, AlertTriangle, SkipBack, SkipForward, Square, Eye, EyeOff, Volume2, Sliders, X, Flag, FileText, Wand, PenTool, ClipboardPaste, ChevronDown, ListChecks, FileOutput, BarChart2, Info } from 'https://esm.sh/lucide-react@0.294.0?deps=react@18.2.0';

        // Web Worker for Transformers.js (AI)
        const workerScript = `
        import { pipeline } from 'https://cdn.jsdelivr.net/npm/@xenova/transformers@2.16.0';
        let transcriber = null;
        self.onmessage = async (event) => {
            const { type, audio, id } = event.data;
            if (type === 'load') {
                try {
                    self.postMessage({ status: 'loading', message: '正在下載 Whisper Tiny 模型 (約 40MB)...' });
                    transcriber = await pipeline('automatic-speech-recognition', 'Xenova/whisper-tiny.en', { quantized: true });
                    self.postMessage({ status: 'ready' });
                } catch (e) { self.postMessage({ status: 'error', message: e.message }); }
            } else if (type === 'run') {
                if (!transcriber) return;
                try {
                    const output = await transcriber(audio, { chunk_length_s: 30, stride_length_s: 5, language: 'english', task: 'transcribe' });
                    self.postMessage({ type: 'result', id, text: output.text });
                } catch (e) { self.postMessage({ type: 'result', id, text: "" }); }
            }
        };
        `;

        // --- Mini Waveform Component ---
        const MiniWaveform = React.memo(({ marker, audioBuffer, onChange, onPlay }) => {
            const canvasRef = useRef(null);
            const [hoverType, setHoverType] = useState(null); 
            const dragRef = useRef(null); 

            if (!marker || !audioBuffer) return <div className="w-full h-full bg-slate-900/50 rounded flex items-center justify-center text-xs text-slate-600">無音訊數據</div>;

            const windowDuration = Math.max((marker.end - marker.start) * 1.5, 3.0); 
            const center = (marker.start + marker.end) / 2;
            const windowStart = Math.max(0, center - windowDuration / 2);
            const windowEnd = Math.min(audioBuffer ? audioBuffer.duration : 0, windowStart + windowDuration);
            const realWindowDuration = windowEnd - windowStart;

            useEffect(() => {
                const canvas = canvasRef.current;
                if (!canvas || !audioBuffer) return;
                const ctx = canvas.getContext('2d');
                const width = canvas.width;
                const height = canvas.height;

                ctx.clearRect(0, 0, width, height);
                ctx.fillStyle = '#0f172a'; 
                ctx.fillRect(0, 0, width, height);

                const sampleRate = audioBuffer.sampleRate;
                const startSample = Math.floor(windowStart * sampleRate);
                const channelData = audioBuffer.getChannelData(0);
                const totalSamples = Math.floor(realWindowDuration * sampleRate);
                const step = Math.ceil(totalSamples / width);
                const amp = height / 2;

                ctx.beginPath();
                ctx.strokeStyle = '#60a5fa'; 
                ctx.lineWidth = 1;

                for (let i = 0; i < width; i++) {
                    let min = 1.0; let max = -1.0;
                    const currentSampleIdx = startSample + i * step;
                    if (currentSampleIdx < channelData.length) {
                         for (let j = 0; j < step; j++) {
                            const datum = channelData[currentSampleIdx + j];
                            if (datum < min) min = datum;
                            if (datum > max) max = datum;
                        }
                    }
                    if (min === 1.0) { min = 0; max = 0; } 
                    ctx.moveTo(i, (1 + min) * amp);
                    ctx.lineTo(i, (1 + max) * amp);
                }
                ctx.stroke();

                const x1 = ((marker.start - windowStart) / realWindowDuration) * width;
                const x2 = ((marker.end - windowStart) / realWindowDuration) * width;

                ctx.fillStyle = 'rgba(239, 68, 68, 0.3)'; 
                ctx.fillRect(x1, 0, x2 - x1, height);

                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.strokeStyle = hoverType === 'start' ? '#ffffff' : 'rgba(239, 68, 68, 0.8)';
                ctx.moveTo(x1, 0); ctx.lineTo(x1, height); ctx.stroke();
                ctx.beginPath();
                ctx.strokeStyle = hoverType === 'end' ? '#ffffff' : 'rgba(239, 68, 68, 0.8)';
                ctx.moveTo(x2, 0); ctx.lineTo(x2, height); ctx.stroke();

                if (hoverType === 'start' || hoverType === 'end') canvas.style.cursor = 'col-resize';
                else if (hoverType === 'body') canvas.style.cursor = 'grab';
                else canvas.style.cursor = 'default';

            }, [marker, audioBuffer, windowStart, realWindowDuration, hoverType]);

            const handleMouseMove = (e) => {
                const canvas = canvasRef.current;
                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                const x = (e.clientX - rect.left) * scaleX;
                const width = canvas.width;
                const time = windowStart + (x / width) * realWindowDuration;

                if (dragRef.current) {
                    const { type, offset } = dragRef.current;
                    let newStart = marker.start;
                    let newEnd = marker.end;
                    if (type === 'body') {
                        const duration = marker.end - marker.start;
                        newStart = time - offset;
                        if (newStart < 0) newStart = 0;
                        if (newStart + duration > audioBuffer.duration) newStart = audioBuffer.duration - duration;
                        newEnd = newStart + duration;
                    } else if (type === 'start') {
                         newStart = time;
                         if (newStart < 0) newStart = 0;
                         if (newStart >= newEnd - 0.05) newStart = newEnd - 0.05;
                    } else if (type === 'end') {
                         newEnd = time;
                         if (newEnd > audioBuffer.duration) newEnd = audioBuffer.duration;
                         if (newEnd <= newStart + 0.05) newEnd = newStart + 0.05;
                    }
                    if(onChange) onChange(marker.id, { start: newStart, end: newEnd });
                } else {
                    const x1 = ((marker.start - windowStart) / realWindowDuration) * width;
                    const x2 = ((marker.end - windowStart) / realWindowDuration) * width;
                    const threshold = 15; 
                    if (Math.abs(x - x1) < threshold) setHoverType('start');
                    else if (Math.abs(x - x2) < threshold) setHoverType('end');
                    else if (x > x1 && x < x2) setHoverType('body');
                    else setHoverType(null);
                }
            };

            const handleMouseDown = (e) => {
                if (!hoverType) return;
                const canvas = canvasRef.current;
                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                const x = (e.clientX - rect.left) * scaleX;
                const width = canvas.width;
                const time = windowStart + (x / width) * realWindowDuration;
                let offset = 0;
                if (hoverType === 'body') offset = time - marker.start;
                dragRef.current = { type: hoverType, offset: offset };
                window.addEventListener('mousemove', handleGlobalMouseMove);
                window.addEventListener('mouseup', handleGlobalMouseUp);
            };

            const handleGlobalMouseMove = (e) => {
                if (!dragRef.current || !canvasRef.current) return;
                const canvas = canvasRef.current;
                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                const x = (e.clientX - rect.left) * scaleX;
                const width = canvas.width;
                let time = windowStart + (x / width) * realWindowDuration;
                const { type, offset } = dragRef.current;
                let newStart = marker.start;
                let newEnd = marker.end;
                const duration = marker.end - marker.start; 
                if (type === 'body') { newStart = time - offset; newEnd = newStart + duration; } 
                else if (type === 'start') { newStart = Math.min(time, marker.end - 0.05); } 
                else if (type === 'end') { newEnd = Math.max(time, marker.start + 0.05); }
                if (newStart < 0) newStart = 0;
                if (newEnd > audioBuffer.duration) newEnd = audioBuffer.duration;
                onChange(marker.id, { start: newStart, end: newEnd });
            };

            const handleGlobalMouseUp = () => {
                dragRef.current = null;
                window.removeEventListener('mousemove', handleGlobalMouseMove);
                window.removeEventListener('mouseup', handleGlobalMouseUp);
            };

            useEffect(() => {
                return () => {
                    window.removeEventListener('mousemove', handleGlobalMouseMove);
                    window.removeEventListener('mouseup', handleGlobalMouseUp);
                };
            }, []);

            return (
                <canvas ref={canvasRef} width={360} height={80} className="rounded border border-slate-600 bg-slate-900 cursor-pointer" onMouseMove={handleMouseMove} onMouseDown={handleMouseDown} onMouseLeave={() => { if(!dragRef.current) setHoverType(null); }} onDoubleClick={onPlay} title="拖曳邊緣調整長度，拖曳中間移動位置，雙擊播放" />
            );
        });

        // --- Main App ---
        const App = () => {
            const [viewMode, setViewMode] = useState('splitter'); 
            const [audioBuffer, setAudioBuffer] = useState(null);
            const [fileName, setFileName] = useState('');
            const [markers, setMarkers] = useState([]);
            const [isPlaying, setIsPlaying] = useState(false);
            const [currentTime, setCurrentTime] = useState(0);
            const [errorMsg, setErrorMsg] = useState('');
            const [isProcessing, setIsProcessing] = useState(false);
            const [isZipping, setIsZipping] = useState(false);
            const [editMode, setEditMode] = useState('auto');
            const [aiStatus, setAiStatus] = useState('idle'); 
            const [aiProgress, setAiProgress] = useState('');
            const [isRecognizing, setIsRecognizing] = useState(false);
            const [scriptData, setScriptData] = useState([]);
            const [scriptFileName, setScriptFileName] = useState('');
            const [scriptFlowMode, setScriptFlowMode] = useState(true);
            const [activeDisplay, setActiveDisplay] = useState(null); 
            const [activeMarkerIndex, setActiveMarkerIndex] = useState(null); 
            const [stagedFiles, setStagedFiles] = useState({}); 
            const [uniqueFileNames, setUniqueFileNames] = useState([]); 
            const [batchPlayingId, setBatchPlayingId] = useState(null);
            const batchAudioRef = useRef(new Audio());
            const [threshold, setThreshold] = useState(-30);
            const [minSilenceDuration, setMinSilenceDuration] = useState(0.4);
            const [minSpeechDuration, setMinSpeechDuration] = useState(0.5);
            const [padding, setPadding] = useState(0.1);
            const [speakerMode, setSpeakerMode] = useState(true);
            const [exportAsRange, setExportAsRange] = useState(true); 
            const [csvEncoding, setCsvEncoding] = useState('utf-8');
            const [doNormalize, setDoNormalize] = useState(true);
            const [targetLoudness, setTargetLoudness] = useState(-16);
            const [expandedDenoiseId, setExpandedDenoiseId] = useState(null);
            const [flagMenuId, setFlagMenuId] = useState(null);
            const [singleInput, setSingleInput] = useState({ filename: '', content: '', secondary: '' });
            const [singleFile, setSingleFile] = useState(null);
            const [rawPaste, setRawPaste] = useState('');
            const [qcList, setQcList] = useState([]); 
            const [batchQcTextRaw, setBatchQcTextRaw] = useState('');
            const [qcAudioFiles, setQcAudioFiles] = useState({}); 
            const [currentlyPlayingQcId, setCurrentlyPlayingQcId] = useState(null);
            const [analyzerResults, setAnalyzerResults] = useState([]);
            const [isAnalyzing, setIsAnalyzing] = useState(false);
            const [zoomLevel, setZoomLevel] = useState(1);
            const [ampScale, setAmpScale] = useState(1);
            const [scrollLeft, setScrollLeft] = useState(0); 
            const [dragTarget, setDragTarget] = useState(null); 
            const [hoverTarget, setHoverTarget] = useState(null); 
            const dragMovedRef = useRef(false);
            const clickStartPosRef = useRef(0);
            const canvasRef = useRef(null);
            const minimapRef = useRef(null);
            const containerRef = useRef(null); 
            const audioContextRef = useRef(null);
            const audioSourceRef = useRef(null);
            const animationRef = useRef(null);
            const startTimeRef = useRef(0);
            const jsZipRef = useRef(window.JSZip);
            const workerRef = useRef(null);
            const [showBigWaveform, setShowBigWaveform] = useState(false);

            const missingCount = useMemo(() => markers.filter(m => m.qualityStatus === 'missing').length, [markers]);

            useEffect(() => {
                const blob = new Blob([workerScript], { type: 'application/javascript' });
                const url = URL.createObjectURL(blob);
                workerRef.current = new Worker(url, { type: 'module' });
                workerRef.current.onmessage = (e) => {
                    const { status, message, type, id, text } = e.data;
                    if (status === 'loading') { setAiStatus('loading'); setAiProgress(message); } 
                    else if (status === 'ready') { setAiStatus('ready'); setAiProgress(''); } 
                    else if (status === 'error') { setAiStatus('error'); setAiProgress(message); } 
                    else if (type === 'result') {
                        setMarkers(prev => prev.map(m => {
                            if (m.id === id) {
                                const similarity = calculateSimilarity(text, m.secondary);
                                return { ...m, recognizedText: text, similarity: similarity };
                            }
                            return m;
                        }));
                    }
                };
                return () => workerRef.current?.terminate();
            }, []);

            useEffect(() => {
                const handleClickOutside = () => { setExpandedDenoiseId(null); setFlagMenuId(null); };
                document.addEventListener('click', handleClickOutside);
                return () => document.removeEventListener('click', handleClickOutside);
            }, []);

            useEffect(() => {
                const handleKeyDown = (e) => {
                    if (viewMode !== 'splitter') return;
                    if (e.key === '[') playPreviousSegment();
                    else if (e.key === ']') playNextSegment();
                    else if (e.code === 'Space') { e.preventDefault(); togglePlay(); }
                    else if (e.key === 'Escape') stopPlayback();
                };
                window.addEventListener('keydown', handleKeyDown);
                return () => window.removeEventListener('keydown', handleKeyDown);
            }, [activeMarkerIndex, markers, isPlaying, audioBuffer, viewMode]);

            // ... (Basic handlers without extra features) ...
            // [Due to token limit, I am compacting common functions which are same as before but without new features]
            
            const handleMarkerUpdate = useCallback((id, newTiming) => { setEditMode('manual'); setMarkers(prev => prev.map(m => { if (m.id === id) { return { ...m, ...newTiming, duration: newTiming.end - newTiming.start, formattedDuration: (newTiming.end - newTiming.start).toFixed(3) + 's' }; } return m; })); }, []);
            const toggleMarkerDenoise = (id) => { setEditMode('manual'); setMarkers(prev => prev.map(m => m.id === id ? { ...m, isDenoised: !m.isDenoised, denoiseParams: m.denoiseParams || { highPassFreq: 100, highShelfGain: -10, peakingGain: 3 } } : m)); };
            const setMarkerIssue = (id, reason) => { setEditMode('manual'); setMarkers(prev => prev.map(m => m.id === id ? { ...m, hasIssue: true, issueReason: reason } : m)); setFlagMenuId(null); };
            const clearMarkerIssue = (id) => { setEditMode('manual'); setMarkers(prev => prev.map(m => m.id === id ? { ...m, hasIssue: false, issueReason: null } : m)); setFlagMenuId(null); };
            const updateMarkerDenoiseParams = (id, newParams) => { setEditMode('manual'); setMarkers(prev => prev.map(m => m.id === id ? { ...m, denoiseParams: { ...m.denoiseParams, ...newParams } } : m)); };
            const deleteMarker = (id) => { setEditMode('manual'); setMarkers(prev => prev.filter(m => m.id !== id)); };

            const getAudioContext = async () => { if (!audioContextRef.current) { const Ctx = window.AudioContext || window.webkitAudioContext; audioContextRef.current = new Ctx(); } if (audioContextRef.current.state === 'suspended') { await audioContextRef.current.resume(); } return audioContextRef.current; };
            const parseCSV = (text) => { const rows = []; let r = []; let c = ''; let q = false; for(let i=0;i<text.length;i++){ const ch=text[i]; if(ch==='"'){if(q&&text[i+1]==='"'){c+='"';i++}else{q=!q}}else if(ch===','&&!q){r.push(c.trim());c=''}else if((ch==='\r'||ch==='\n')&&!q){if(c||r.length>0)r.push(c.trim());if(r.length>0)rows.push(r);r=[];c='';if(ch==='\r'&&text[i+1]==='\n')i++}else{c+=ch} } if(c||r.length>0){r.push(c.trim());rows.push(r)} return rows; };

            const concatAudioBuffers = (buffers, ctx) => { if(buffers.length===0) return ctx.createBuffer(1,1,44100); let len=0; buffers.forEach(b=>len+=b.length); let ch=1; buffers.forEach(b=>ch=Math.max(ch, b.numberOfChannels)); const res=ctx.createBuffer(ch, len, buffers[0].sampleRate); let off=0; buffers.forEach(b=>{ for(let c=0;c<ch;c++){ if(c<b.numberOfChannels) res.getChannelData(c).set(b.getChannelData(c), off); else if(b.numberOfChannels===1) res.getChannelData(c).set(b.getChannelData(0), off); } off+=b.length; }); return res; };
            
            const handleScriptUpload = async (e) => { const f=e.target.files[0]; if(!f)return; const ab=await f.arrayBuffer(); const dec=new TextDecoder(csvEncoding); const txt=dec.decode(ab); const rows=parseCSV(txt); const head=rows[0].map(h=>h.toLowerCase()); let sIdx=head.indexOf('filename'); let tIdx=head.indexOf('new_filename'); if(sIdx===-1) sIdx=head.findIndex(h=>h.includes('file')); const data=rows.slice(1).map((r,i)=>{ const p=r[0]||""; let s=sIdx!==-1?r[sIdx]:""; let t=tIdx!==-1?r[tIdx]:""; if(!t&&p) t=`${(i+1).toString().padStart(3,'0')}_${p.replace(/[\\/:*?"<>|]/g,'')}`; let sec=""; if(tIdx!==-1&&tIdx+1<r.length) sec=r[tIdx+1]; return {id:i+1, primary:p, secondary:sec, sourceFileName:s, targetFileName:t}; }); setUniqueFileNames([...new Set(data.map(d=>d.sourceFileName).filter(Boolean))]); setScriptData(data); setScriptFileName(f.name); e.target.value=null; };
            const handleStagedFilesUpload = (e) => { const files=Array.from(e.target.files); const n={...stagedFiles}; files.forEach(f=>n[f.name]=f); setStagedFiles(n); e.target.value=null; };
            const removeStagedFile = (n) => { const ns={...stagedFiles}; delete ns[n]; setStagedFiles(ns); };
            
            const handleMergeAndLoad = async () => { setIsProcessing(true); try { const ctx=await getAudioContext(); const bufs=[]; const newMk=[]; let off=0; const fileBufs={}; const fileSegs={}; const needed=[...new Set(scriptData.map(r=>r.sourceFileName).filter(Boolean))]; for(const n of needed){ if(stagedFiles[n]){ try{ const ab=await stagedFiles[n].arrayBuffer(); const dec=await ctx.decodeAudioData(ab); fileBufs[n]=dec; fileSegs[n]=getSegmentsInFile(dec.getChannelData(0), dec.sampleRate, threshold, minSilenceDuration, minSpeechDuration); }catch(e){console.warn(e);} } } let lastN=null; let batch=[]; const procBatch=(n, rows)=>{ const b=fileBufs[n]; if(b){ bufs.push(b); const segs=fileSegs[n]||[]; const dur=b.duration; rows.forEach((r,i)=>{ let s=0,e=0,qt='Auto-Matched'; if(segs.length>=rows.length){ const sg=segs[i]; s=sg.start; e=sg.end; }else{ const p=dur/rows.length; s=i*p; e=(i+1)*p; qt='Fallback-Split'; } newMk.push({id:r.id, lockedText:{name:r.primary, secondary:r.secondary, previewFileName:r.targetFileName}, start:off+s, end:off+e, duration:e-s, formattedDuration:(e-s).toFixed(3)+'s', qualityStatus:'normal', qualityText:qt, isDenoised:false, denoiseParams:{highPassFreq:100, highShelfGain:-10, peakingGain:3}, hasIssue:false}); }); off+=dur; }else{ rows.forEach(r=>newMk.push({id:r.id, lockedText:{name:r.primary, secondary:r.secondary, previewFileName:r.targetFileName}, start:-1, end:-1, qualityStatus:'missing'})); } }; scriptData.forEach(r=>{ if(r.sourceFileName!==lastN){ if(lastN!==null) procBatch(lastN, batch); batch=[r]; lastN=r.sourceFileName; }else{ batch.push(r); } }); if(batch.length) procBatch(lastN, batch); const mg=concatAudioBuffers(bufs, ctx); setAudioBuffer(mg); setMarkers(newMk); setFileName('Merged_Project'); setViewMode('splitter'); setEditMode('manual'); setShowBigWaveform(true); }catch(e){ alert(e.message); }finally{ setIsProcessing(false); } };

            const handleSingleFileUpload = async (e) => { const f=e.target.files[0]; if(!f)return; setIsProcessing(true); setFileName(f.name); try{ const ctx=await getAudioContext(); const ab=await f.arrayBuffer(); const dec=await ctx.decodeAudioData(ab); setAudioBuffer(dec); setCurrentTime(0); setMarkers([]); setEditMode('auto'); setShowBigWaveform(true); }catch(e){ alert("Error"); }finally{ setIsProcessing(false); e.target.value=null; } };

            const getSegmentsInFile = (data, rate, th, minSil, minSp) => { const len=data.length; const thL=Math.pow(10, th/20); const minSilS=minSil*rate; const minSpS=minSp*rate; const pad=0.1*rate; let isSp=false; let spStart=0; let segs=[]; let silCnt=0; const step=100; for(let i=0;i<len;i+=step){ const amp=Math.abs(data[i]); if(amp>thL){ if(!isSp){ isSp=true; spStart=i; } silCnt=0; }else{ if(isSp){ silCnt+=step; if(silCnt>minSilS){ const spEnd=i-silCnt; if(spEnd-spStart>minSpS){ let s=Math.max(0, spStart-pad); let e=Math.min(len, spEnd+pad); segs.push({start:s/rate, end:e/rate}); } isSp=false; } } } } if(isSp){ let s=Math.max(0, spStart-pad); segs.push({start:s/rate, end:len/rate}); } return segs; };
            
            const encodeWAV = (samples, ch, rate) => { const b=new ArrayBuffer(44+samples.length*2); const v=new DataView(b); const w=(o,s)=>{for(let i=0;i<s.length;i++)v.setUint8(o+i,s.charCodeAt(i))}; w(0,'RIFF'); v.setUint32(4,36+samples.length*2,true); w(8,'WAVE'); w(12,'fmt '); v.setUint32(16,16,true); v.setUint16(20,1,true); v.setUint16(22,ch,true); v.setUint32(24,rate,true); v.setUint32(28,rate*ch*2,true); v.setUint16(32,ch*2,true); v.setUint16(34,16,true); w(36,'data'); v.setUint32(40,samples.length*2,true); for(let i=0;i<samples.length;i++){ let s=Math.max(-1,Math.min(1,samples[i])); s=s<0?s*0x8000:s*0x7FFF; v.setInt16(44+i*2,s,true); } return new Blob([v],{type:'audio/wav'}); };

            const normalizeAudioData = (data, db) => { let sum=0; for(let i=0;i<data.length;i++)sum+=data[i]*data[i]; const rms=Math.sqrt(sum/data.length); if(rms<0.0001)return data; const gain=Math.pow(10, (db-20*Math.log10(rms))/20); const n=new Float32Array(data.length); for(let i=0;i<data.length;i++){ let v=data[i]*gain; if(v>1)v=1; if(v<-1)v=-1; n[i]=v; } return n; };

            const processAudioSegment = async (raw, rate, opts) => { const ctx=new OfflineAudioContext(1, raw.length, rate); const src=ctx.createBufferSource(); const buf=ctx.createBuffer(1, raw.length, rate); buf.getChannelData(0).set(raw); src.buffer=buf; const hp=ctx.createBiquadFilter(); hp.type='highpass'; hp.frequency.value=opts.highPassFreq; const dh=ctx.createBiquadFilter(); dh.type='highshelf'; dh.frequency.value=opts.highShelfGain; const pr=ctx.createBiquadFilter(); pr.type='peaking'; pr.frequency.value=2500; pr.gain.value=opts.peakingGain; src.connect(hp); hp.connect(dh); dh.connect(pr); pr.connect(ctx.destination); src.start(); const ren=await ctx.startRendering(); return ren.getChannelData(0); };

            const getAudioSegmentBlobAsync = async (s, e, dp) => { if(!audioBuffer)return null; const pad=0.1; const ps=Math.max(0, s-pad); const pe=Math.min(audioBuffer.duration, e+pad); const rate=audioBuffer.sampleRate; const ss=Math.floor(ps*rate); const ee=Math.floor(pe*rate); const len=ee-ss; if(len<=0)return null; const ch=audioBuffer.numberOfChannels; let pc=[]; for(let c=0;c<ch;c++){ let d=audioBuffer.getChannelData(c).slice(ss, ss+len); if(dp){ try{ const o={highPassFreq:dp.highPassFreq, highShelfGain:dp.highShelfGain, peakingGain:dp.peakingGain}; d=await processAudioSegment(d, rate, o); }catch(e){} } if(doNormalize) pc.push(normalizeAudioData(d, targetLoudness)); else pc.push(d); } let il; if(ch===2){ il=new Float32Array(len*2); for(let i=0;i<len;i++){ il[i*2]=pc[0][i]; il[i*2+1]=pc[1][i]; } }else{ il=pc[0]; } return encodeWAV(il, ch, rate); };

            const downloadSegment = async (m, i) => { if(m.qualityStatus==='missing')return; const res=resolveMarkerData(m,i); const b=await getAudioSegmentBlobAsync(m.start, m.end, m.isDenoised?m.denoiseParams:null); if(!b)return; const url=URL.createObjectURL(b); const a=document.createElement('a'); a.href=url; let n=res.previewFileName; if(!n.endsWith('.wav')) n+='.wav'; a.download=n; document.body.appendChild(a); a.click(); document.body.removeChild(a); };
            
            const downloadAllZip = async () => { if(!jsZipRef.current||markers.length===0)return; setIsZipping(true); const zip=new jsZipRef.current(); const folder=zip.folder(fileName.split('.')[0]+"_sliced"); let c=0; for(let i=0;i<markers.length;i++){ const m=markers[i]; if(m.qualityStatus==='missing')continue; const res=resolveMarkerData(m,i); const b=await getAudioSegmentBlobAsync(m.start, m.end, m.isDenoised?m.denoiseParams:null); if(b){ let n=res.previewFileName; if(!n.endsWith('.wav')) n+='.wav'; folder.file(n, b); c++; } } if(c===0){ alert("無檔案"); setIsZipping(false); return; } const content=await zip.generateAsync({type:"blob"}); const url=URL.createObjectURL(content); const a=document.createElement('a'); a.href=url; a.download=`${fileName.split('.')[0]}_sliced.zip`; document.body.appendChild(a); a.click(); document.body.removeChild(a); setIsZipping(false); };
            
            const downloadIssueReport = () => { const iss=markers.filter(m=>m.hasIssue); if(iss.length===0){alert("無問題");return;} let c=`Report - ${fileName}\n\n`; iss.forEach(m=>{ const res=resolveMarkerData(m, markers.findIndex(mk=>mk.id===m.id)); c+=`[ID:${m.id}] ${res.name}\n${m.issueReason}\nTime: ${m.formattedDuration}\nFile: ${res.previewFileName}\n---\n`; }); const b=new Blob([c],{type:'text/plain'}); const u=URL.createObjectURL(b); const a=document.createElement('a'); a.href=u; a.download='issues.txt'; a.click(); };
            
            const exportCSV = () => { if(markers.length===0)return; let c="Name\tStart\tDuration\tFormat\tType\tDesc\n"; markers.forEach((m,i)=>{ if(m.qualityStatus==='missing')return; const res=resolveMarkerData(m,i); c+=`${res.name}\t${m.start.toFixed(3)}\t${m.duration.toFixed(3)}\tdecimal\tCue\t${res.previewFileName}\n`; }); const b=new Blob(["\uFEFF"+c],{type:'text/csv;charset=utf-8;'}); const u=URL.createObjectURL(b); const a=document.createElement('a'); a.href=u; a.download='markers.csv'; a.click(); };

            const calculateSimilarity = (s1, s2) => { if(!s1||!s2) return 0; const a=s1.toLowerCase(); const b=s2.toLowerCase(); if(a===b) return 100; return 0; }; // Simplistic for v1

            // Playback
            const playMarkerByIndex = async (index) => { if(index<0||index>=markers.length)return; const m=markers[index]; if(m.qualityStatus==='missing')return; if(m.isDenoised){ stopPlayback(); const b=await getAudioSegmentBlobAsync(m.start,m.end,m.denoiseParams); const u=URL.createObjectURL(b); const a=new Audio(u); a.play(); audioSourceRef.current={stop:()=>a.pause()}; }else{ playRange(m.start, m.duration); } setActiveDisplay(resolveMarkerData(m,index)); setActiveMarkerIndex(index); };
            const stopPlayback = () => { if(audioSourceRef.current){audioSourceRef.current.stop();audioSourceRef.current=null;} cancelAnimationFrame(animationRef.current); setIsPlaying(false); };
            const togglePlay = async () => { if(!audioBuffer)return; const ctx=await getAudioContext(); if(isPlaying){ stopPlayback(); }else{ const src=ctx.createBufferSource(); src.buffer=audioBuffer; src.connect(ctx.destination); let off=currentTime>=audioBuffer.duration?0:currentTime; src.start(0, off); startTimeRef.current=ctx.currentTime-off; audioSourceRef.current=src; setIsPlaying(true); const loop=()=>{ const now=ctx.currentTime-startTimeRef.current; if(now>=audioBuffer.duration){ setIsPlaying(false); setCurrentTime(0); return; } setCurrentTime(now); animationRef.current=requestAnimationFrame(loop); }; loop(); } };
            const playRange = async (s, d) => { if(!audioBuffer)return; const ctx=await getAudioContext(); if(isPlaying) stopPlayback(); const src=ctx.createBufferSource(); src.buffer=audioBuffer; src.connect(ctx.destination); src.start(0, s, d); setCurrentTime(s); setIsPlaying(true); startTimeRef.current=ctx.currentTime-s; if(containerRef.current&&canvasRef.current){ const w=canvasRef.current.width; const p=(s/audioBuffer.duration)*w - (containerRef.current.clientWidth/2); containerRef.current.scrollTo({left:p, behavior:'smooth'}); } setTimeout(()=>setIsPlaying(false), d*1000); audioSourceRef.current=src; const loop=()=>{ const now=ctx.currentTime-startTimeRef.current; if(now>=s+d) return; setCurrentTime(now); animationRef.current=requestAnimationFrame(loop); }; loop(); };
            const playPreviousSegment = () => { let i=activeMarkerIndex!==null?activeMarkerIndex-1:0; while(i>=0 && markers[i].qualityStatus==='missing') i--; if(i>=0) playMarkerByIndex(i); };
            const playNextSegment = () => { let i=activeMarkerIndex!==null?activeMarkerIndex+1:0; while(i<markers.length && markers[i].qualityStatus==='missing') i++; if(i<markers.length) playMarkerByIndex(i); };

            // Canvas
            const getCanvasX = (e) => { if(!canvasRef.current)return 0; const r=canvasRef.current.getBoundingClientRect(); const s=canvasRef.current.width/r.width; return (e.clientX-r.left)*s; };
            const handleCanvasMouseDown = (e) => { if(!audioBuffer)return; const x=getCanvasX(e); const t=(x/canvasRef.current.width)*audioBuffer.duration; if(hoverTarget){ let off=0; if(hoverTarget.type==='body'){ const m=markers.find(k=>k.id===hoverTarget.id); if(m) off=t-m.start; } clickStartPosRef.current=x; dragMovedRef.current=false; setEditMode('manual'); setDragTarget({...hoverTarget, offset:off}); setIsPlaying(false); }else{ setEditMode('manual'); setDragTarget({type:'create', startX:x, startTime:t}); setCurrentTime(t); } };
            const handleCanvasMouseMove = (e) => { if(!audioBuffer)return; const x=getCanvasX(e); const t=(x/canvasRef.current.width)*audioBuffer.duration; if(dragTarget){ if(dragTarget.type==='body' && Math.abs(x-clickStartPosRef.current)>5) dragMovedRef.current=true; const {id,type,offset}=dragTarget; setMarkers(prev=>prev.map(m=>{ if(m.id!==id)return m; let ns=m.start, ne=m.end, d=m.end-m.start; if(type==='start') ns=Math.min(t, m.end-0.1); if(type==='end') ne=Math.max(t, m.start+0.1); if(type==='body'){ ns=t-offset; if(ns<0)ns=0; if(ns+d>audioBuffer.duration)ns=audioBuffer.duration-d; ne=ns+d; } return {...m, start:ns, end:ne, duration:ne-ns, formattedDuration:(ne-ns).toFixed(3)+'s'}; })); return; } let tgt=null; const w=canvasRef.current.width; const th=12*(w/canvasRef.current.getBoundingClientRect().width); for(const m of markers){ if(m.qualityStatus==='missing')continue; const sx=(m.start/audioBuffer.duration)*w; const ex=(m.end/audioBuffer.duration)*w; if(Math.abs(x-sx)<th){ tgt={id:m.id, type:'start'}; break; } if(Math.abs(x-ex)<th){ tgt={id:m.id, type:'end'}; break; } if(x>sx && x<ex){ tgt={id:m.id, type:'body'}; break; } } setHoverTarget(tgt); };
            const handleCanvasMouseUp = (e) => { if(dragTarget?.type==='body' && !dragMovedRef.current){ const i=markers.findIndex(m=>m.id===dragTarget.id); if(i!==-1) playMarkerByIndex(i); } if(dragTarget?.type==='create'){ const ex=getCanvasX(e); const et=(ex/canvasRef.current.width)*audioBuffer.duration; if(Math.abs(ex-dragTarget.startX)>10){ const s=Math.min(dragTarget.startTime, et); const e=Math.max(dragTarget.startTime, et); const newId=markers.length>0?Math.max(...markers.map(m=>m.id))+1:1; setMarkers(p=>[...p, {id:newId, name:`New ${newId}`, previewFileName:`new_${newId}`, start:s, end:e, duration:e-s, formattedDuration:(e-s).toFixed(3)+'s', qualityStatus:'normal', isDenoised:false, denoiseParams:{highPassFreq:100, highShelfGain:-10, peakingGain:3}, hasIssue:false}].sort((a,b)=>a.start-b.start)); } } setDragTarget(null); };
            const handleCanvasMouseLeave = () => { setDragTarget(null); setHoverTarget(null); };
            const handleSliderChange = (setter) => (e) => { setEditMode('auto'); setter(Number(e.target.value)); };
            const detectMarkers = useMemo(() => { if (!audioBuffer) return []; const rawData = audioBuffer.getChannelData(0); const sampleRate = audioBuffer.sampleRate; const bufferLength = rawData.length; const thresholdLinear = Math.pow(10, threshold / 20); const minSilenceSamples = minSilenceDuration * sampleRate; const minSpeechSamples = minSpeechDuration * sampleRate; const paddingSamples = padding * sampleRate; let isSpeaking = false; let speechStart = 0; let tempMarkers = []; let silenceCount = 0; const step = 100; for (let i = 0; i < bufferLength; i += step) { const amplitude = Math.abs(rawData[i]); if (amplitude > thresholdLinear) { if (!isSpeaking) { isSpeaking = true; speechStart = i; } silenceCount = 0; } else { if (isSpeaking) { silenceCount += step; if (silenceCount > minSilenceSamples) { const speechEnd = i - silenceCount; if (speechEnd - speechStart > minSpeechSamples) { let startSample = Math.max(0, speechStart - paddingSamples); let endSample = Math.min(bufferLength, speechEnd + paddingSamples); tempMarkers.push({ rawStart: startSample / sampleRate, rawDuration: (endSample - startSample) / sampleRate, rawEnd: endSample / sampleRate }); } isSpeaking = false; } } } } if(isSpeaking){let s=Math.max(0, speechStart-paddingSamples); tempMarkers.push({rawStart:s/sampleRate, rawEnd:bufferLength/sampleRate, rawDuration:(bufferLength-s)/sampleRate});} return tempMarkers.map((m, index) => ({ id: index + 1, start: m.rawStart, end: m.rawEnd, duration: m.rawDuration, formattedStart: formatTime(m.rawStart), formattedDuration: m.rawDuration.toFixed(3) + 's', qualityStatus: 'normal', qualityText: 'Auto', isDenoised: false, denoiseParams: { highPassFreq: 100, highShelfGain: -10, peakingGain: 3 }, hasIssue: false, issueReason: null })); }, [audioBuffer, threshold, minSilenceDuration, minSpeechDuration, padding, speakerMode, scriptData]);
            useEffect(() => { if (viewMode === 'splitter' && editMode === 'auto' && detectMarkers.length > 0) { setMarkers(detectMarkers); } }, [detectMarkers, viewMode, editMode]);

            // --- Other Handlers ---
            const handleManualInputSubmit = async () => { if (!singleInput.filename || !singleInput.content || !singleFile) { alert("請填寫所有欄位並上傳音檔"); return; } try { setIsProcessing(true); const ctx = await getAudioContext(); const arrayBuffer = await singleFile.arrayBuffer(); const decodedBuffer = await ctx.decodeAudioData(arrayBuffer); setAudioBuffer(decodedBuffer); setCurrentTime(0); setFileName(singleFile.name); setViewMode('splitter'); const rawMarkers = getSegmentsInFile(decodedBuffer.getChannelData(0), decodedBuffer.sampleRate, threshold, minSilenceDuration, minSpeechDuration); let markerStart = 0; let markerEnd = decodedBuffer.duration; if (rawMarkers.length > 0) { markerStart = rawMarkers[0].start; markerEnd = rawMarkers[rawMarkers.length - 1].end; } const newMarker = { id: 1, start: markerStart, end: markerEnd, duration: markerEnd - markerStart, formattedDuration: (markerEnd - markerStart).toFixed(3) + 's', qualityStatus: 'normal', qualityText: 'Manual Input', isDenoised: false, hasIssue: false, issueReason: null, denoiseParams: { highPassFreq: 100, highShelfGain: -10, peakingGain: 3 }, lockedText: { name: singleInput.content, secondary: singleInput.secondary, previewFileName: singleInput.filename } }; setMarkers([newMarker]); setEditMode('manual'); setScriptData([]); setScriptFileName(''); setShowBigWaveform(true); } catch (e) { console.error(e); alert("處理失敗：請確認音檔格式"); } finally { setIsProcessing(false); } };
            const handleRawInputChange = (e) => { const val = e.target.value; setRawPaste(val); const match = val.match(/^([^\s]+)[\s\t]+(.+)$/s); if (match) { setSingleInput({ filename: match[1], content: match[2], secondary: match[2] }); } else if (val.trim()) { setSingleInput(prev => ({ ...prev, content: val, secondary: val })); } };
            const handleBatchQcTextChange = (e) => { setBatchQcTextRaw(e.target.value); };
            const handleBatchQcFilesUpload = (e) => { const files = Array.from(e.target.files); if (files.length === 0) return; const newMap = { ...qcAudioFiles }; files.forEach(f => newMap[f.name] = f); setQcAudioFiles(newMap); e.target.value = null; };
            const processBatchQcList = async () => { if (!batchQcTextRaw.trim()) { alert("請先貼上資料"); return; } setIsProcessing(true); try { const ctx = await getAudioContext(); const lines = batchQcTextRaw.split('\n').filter(l => l.trim()); const newList = []; const sortedFilenames = Object.keys(qcAudioFiles).sort((a, b) => a.localeCompare(b, undefined, { numeric: true, sensitivity: 'base' })); for (let i = 0; i < lines.length; i++) { const line = lines[i]; const match = line.match(/^([^\s]+)[\s\t]+(.+)$/s); let targetName = ""; let content = ""; if (match) { targetName = match[1]; content = match[2]; } else { targetName = `track_${i+1}`; content = line; } let matchedFile = null; let buffer = null; let status = 'missing'; if (i < sortedFilenames.length) { const srcName = sortedFilenames[i]; matchedFile = qcAudioFiles[srcName]; try { const ab = await matchedFile.arrayBuffer(); buffer = await ctx.decodeAudioData(ab); status = 'ready'; } catch (e) { console.error("Decode fail", srcName); status = 'error'; } } newList.push({ id: i + 1, originalName: matchedFile ? matchedFile.name : "(無)", targetName: targetName, content: content, audioBuffer: buffer, status: status, isDenoised: false, denoiseParams: { highPassFreq: 100, highShelfGain: -10, peakingGain: 3 }, hasIssue: false, issueReason: null }); } setQcList(newList); } catch (e) { console.error(e); alert("處理發生錯誤"); } finally { setIsProcessing(false); } };
            const toggleQcDenoise = (id) => { setQcList(prev => prev.map(item => item.id === id ? { ...item, isDenoised: !item.isDenoised } : item)); };
            const setQcIssue = (id, r) => { setQcList(prev => prev.map(item => item.id === id ? { ...item, hasIssue: true, issueReason: r } : item)); setFlagMenuId(null); };
            const clearQcIssue = (id) => { setQcList(prev => prev.map(item => item.id === id ? { ...item, hasIssue: false, issueReason: null } : item)); setFlagMenuId(null); };
            const playQcItem = async (item) => { if (!item.audioBuffer) return; if (batchAudioRef.current) { batchAudioRef.current.pause(); batchAudioRef.current = new Audio(); } if (currentlyPlayingQcId === item.id) { setCurrentlyPlayingQcId(null); return; } let wavBlob; if (item.isDenoised) { wavBlob = await processBufferToBlob(item.audioBuffer, item.denoiseParams); } else { wavBlob = await processBufferToBlob(item.audioBuffer, null); } const url = URL.createObjectURL(wavBlob); batchAudioRef.current.src = url; batchAudioRef.current.play(); setCurrentlyPlayingQcId(item.id); batchAudioRef.current.onended = () => setCurrentlyPlayingQcId(null); };
            const downloadQcZip = async () => { if (!jsZipRef.current || qcList.length === 0) return; setIsZipping(true); const zip = new jsZipRef.current(); const folder = zip.folder("Batch_Processed"); let count = 0; for (const item of qcList) { if (item.status === 'missing' || !item.audioBuffer) continue; const blob = await processBufferToBlob(item.audioBuffer, item.isDenoised ? item.denoiseParams : null); let name = item.targetName; if (!name.toLowerCase().endsWith('.wav')) name += '.wav'; folder.file(name, blob); count++; } if (count === 0) { alert("沒有可處理的檔案"); setIsZipping(false); return; } const content = await zip.generateAsync({ type: "blob" }); const link = document.createElement('a'); link.href = URL.createObjectURL(content); link.download = "Batch_Output.zip"; link.click(); setIsZipping(false); };
            const downloadQcReport = () => { let content = `驗收報表 (QC Report)\n日期: ${new Date().toLocaleString()}\n\n`; content += `ID, 原始檔名, 目標檔名, 狀態, 問題標記, 內容\n`; qcList.forEach(item => { const status = item.status === 'ready' ? 'OK' : 'Missing'; const issue = item.hasIssue ? item.issueReason : 'None'; content += `${item.id}, ${item.originalName}, ${item.targetName}, ${status}, ${issue}, ${item.content}\n`; }); const blob = new Blob([content], { type: 'text/csv;charset=utf-8' }); const link = document.createElement('a'); link.href = URL.createObjectURL(blob); link.download = "QC_Report.csv"; link.click(); };
            const handleAnalyzerUpload = async (e) => { const fileList = e.target.files; if (!fileList || fileList.length === 0) return; const files = Array.from(fileList); setIsAnalyzing(true); e.target.value = null; await new Promise(r => setTimeout(r, 50)); const newResults = []; try { const ctx = await getAudioContext(); for (let i = 0; i < files.length; i++) { const file = files[i]; try { const arrayBuffer = await file.arrayBuffer(); const audioBuffer = await ctx.decodeAudioData(arrayBuffer); let maxPeak = 0; let totalSumSquares = 0; let totalLength = 0; for (let c = 0; c < audioBuffer.numberOfChannels; c++) { const data = audioBuffer.getChannelData(c); for (let j = 0; j < data.length; j++) { const abs = Math.abs(data[j]); if (abs > maxPeak) maxPeak = abs; totalSumSquares += data[j] * data[j]; } totalLength += data.length; } const rms = Math.sqrt(totalSumSquares / totalLength); const peakDb = 20 * Math.log10(maxPeak); const rmsDb = 20 * Math.log10(rms); newResults.push({ id: Date.now() + Math.random(), filename: file.name, duration: audioBuffer.duration, channels: audioBuffer.numberOfChannels, sampleRate: audioBuffer.sampleRate, peakDb: peakDb.toFixed(2), rmsDb: rmsDb.toFixed(2), peakLinear: maxPeak, rmsLinear: rms, status: 'success' }); } catch (err) { console.error(`Error analyzing ${file.name}:`, err); newResults.push({ id: Date.now() + Math.random(), filename: file.name, status: 'error', errorMsg: '解碼失敗 (可能格式不支援)' }); } } setAnalyzerResults(prev => [...prev, ...newResults]); } catch (e) { console.error("Batch analysis fatal error:", e); alert("批次分析發生錯誤: " + e.message); } finally { setIsAnalyzing(false); } };
            const clearAnalyzerResults = () => { setAnalyzerResults([]); };
            const exportAnalyzerReport = () => { if (analyzerResults.length === 0) return; let content = "Filename,Duration (s),SampleRate (Hz),Channels,Peak (dB),RMS (dB),Status\n"; analyzerResults.forEach(r => { if (r.status === 'success') { content += `${r.filename},${r.duration.toFixed(2)},${r.sampleRate},${r.channels},${r.peakDb},${r.rmsDb},OK\n`; } else { content += `${r.filename},,,,,,Error\n`; } }); const blob = new Blob([content], { type: 'text/csv;charset=utf-8;' }); const link = document.createElement("a"); link.href = URL.createObjectURL(blob); link.download = `Audio_Analysis_Report_${new Date().toISOString().slice(0,10)}.csv`; link.click(); };

            return (
                <div className="min-h-screen bg-slate-900 text-slate-100 p-6 font-sans">
                <div className="max-w-7xl mx-auto space-y-6">
                    
                    {/* TOP HEADER */}
                    <div className="flex flex-col xl:flex-row justify-between items-start xl:items-center border-b border-slate-700 pb-4 gap-4">
                        <div>
                            <h1 className="text-2xl font-bold flex items-center gap-2">
                            <BrainCircuit className="text-purple-500" />
                            小寶貝5.0 (v1.0 Classic)
                            </h1>
                            <p className="text-slate-400 text-sm mt-1">單檔自動切分 (Auto-Split) 與 多檔依序合併 (Batch Merge)</p>
                        </div>
                        <div className="flex bg-slate-800 p-1 rounded-lg border border-slate-700">
                            <button onClick={() => setViewMode('splitter')} className={`flex items-center gap-2 px-4 py-2 rounded-lg text-sm font-bold transition ${viewMode === 'splitter' ? 'bg-blue-600 text-white' : 'text-slate-400 hover:text-white'}`}><Scissors size={16} /> 切分 / 編輯</button>
                            <button onClick={() => setViewMode('merger')} className={`flex items-center gap-2 px-4 py-2 rounded-lg text-sm font-bold transition ${viewMode === 'merger' ? 'bg-purple-600 text-white' : 'text-slate-400 hover:text-white'}`}><Merge size={16} /> 批次合併</button>
                            <button onClick={() => setViewMode('manual_input')} className={`flex items-center gap-2 px-4 py-2 rounded-lg text-sm font-bold transition ${viewMode === 'manual_input' ? 'bg-green-600 text-white' : 'text-slate-400 hover:text-white'}`}><PenTool size={16} /> 單句輸入</button>
                            <button onClick={() => setViewMode('batch_qc')} className={`flex items-center gap-2 px-4 py-2 rounded-lg text-sm font-bold transition ${viewMode === 'batch_qc' ? 'bg-orange-600 text-white' : 'text-slate-400 hover:text-white'}`}><ListChecks size={16} /> 產線</button>
                            <button onClick={() => setViewMode('loudness_analyzer')} className={`flex items-center gap-2 px-4 py-2 rounded-lg text-sm font-bold transition ${viewMode === 'loudness_analyzer' ? 'bg-cyan-600 text-white' : 'text-slate-400 hover:text-white'}`}><Activity size={16} /> 音量檢測</button>
                        </div>
                        <div className="flex flex-wrap gap-3 w-full xl:w-auto items-center">
                            {/* Toolbar content based on mode */}
                            {(viewMode === 'splitter' || viewMode === 'merger') && (
                                <>
                                {!scriptFileName ? (
                                <div className="flex gap-2">
                                    <select 
                                        value={csvEncoding} 
                                        onChange={(e) => setCsvEncoding(e.target.value)}
                                        className="bg-slate-700 text-xs px-2 rounded border border-slate-600 outline-none"
                                        title="若文字亂碼，請切換此編碼重新載入"
                                    >
                                        <option value="utf-8">UTF-8</option>
                                        <option value="big5">Big5</option>
                                    </select>
                                    <label className={`flex items-center justify-center gap-2 bg-slate-700 hover:bg-slate-600 transition px-4 py-2 rounded-lg cursor-pointer font-medium border border-slate-600`}>
                                        <FileSpreadsheet size={18} className="text-green-400"/> <span className="text-sm">載入腳本</span>
                                        <input type="file" accept=".csv,.txt" onChange={handleScriptUpload} className="hidden" />
                                    </label>
                                </div>
                            ) : (
                                <div className="flex items-center gap-2 bg-emerald-900/30 border border-emerald-700/50 px-3 py-2 rounded-lg">
                                    <FileSpreadsheet size={16} className="text-emerald-400"/>
                                    <span className="text-sm text-emerald-100 truncate max-w-[100px]">{scriptFileName}</span>
                                    <button onClick={() => {setScriptData([]); setScriptFileName('');}} className="text-slate-400 hover:text-red-400 p-1"><Trash2 size={14}/></button>
                                </div>
                            )}
                            </>
                            )}

                            {viewMode === 'splitter' && (
                                <>
                                    {audioBuffer && scriptData.length > 0 && (
                                        <div className="flex items-center gap-2 mr-4 bg-slate-800 p-1.5 rounded-lg border border-slate-700">
                                            {aiStatus === 'idle' && (
                                                <button onClick={loadAiModel} className="flex items-center gap-2 px-3 py-1.5 bg-purple-600 hover:bg-purple-700 rounded text-xs font-bold transition">
                                                    <BrainCircuit size={14} /> AI
                                                </button>
                                            )}
                                            {aiStatus === 'loading' && <span className="text-xs text-purple-300 animate-pulse px-2">{aiProgress || '載入中...'}</span>}
                                            {aiStatus === 'ready' && (
                                                <button onClick={runRecognition} disabled={isRecognizing} className="flex items-center gap-2 px-3 py-1.5 bg-purple-600 hover:bg-purple-700 disabled:opacity-50 rounded text-xs font-bold transition">
                                                    {isRecognizing ? <RefreshCw className="animate-spin" size={14}/> : <Wand2 size={14} />} {isRecognizing ? '辨識' : '辨識'}
                                                </button>
                                            )}
                                        </div>
                                    )}
                                    <label className={`flex items-center justify-center gap-2 bg-blue-600 hover:bg-blue-700 transition px-4 py-2 rounded-lg cursor-pointer font-medium ${isProcessing ? 'opacity-50 cursor-not-allowed' : ''}`}>
                                        <Upload size={18} /> <span>單音檔</span>
                                        <input type="file" accept="audio/*" onChange={handleSingleFileUpload} disabled={isProcessing} className="hidden" />
                                    </label>
                                    <button onClick={downloadIssueReport} disabled={markers.length === 0} className={`bg-red-900 hover:bg-red-700 transition px-4 py-2 rounded-lg flex items-center gap-2 text-red-100`} title="下載問題報告">
                                        <FileText size={18} /> <span>筆記</span>
                                    </button>
                                    <button onClick={downloadAllZip} disabled={markers.length === 0 || isZipping} className={`bg-indigo-600 hover:bg-indigo-700 disabled:opacity-50 transition px-4 py-2 rounded-lg`} title="打包下載">
                                        {isZipping ? <RefreshCw className="animate-spin" size={18}/> : <Package size={18} />}
                                    </button>
                                    <button onClick={exportCSV} disabled={markers.length === 0} className="bg-emerald-600 hover:bg-emerald-700 disabled:opacity-50 transition px-4 py-2 rounded-lg" title="匯出 CSV">
                                        <Download size={18} />
                                    </button>
                                </>
                            )}
                        </div>
                    </div>

                    {errorMsg && <div className="bg-red-500/20 border border-red-500/50 text-red-200 p-3 rounded-lg flex items-center gap-2"><AlertCircle size={20} /><span>{errorMsg}</span></div>}

                    {/* LOUDNESS ANALYZER VIEW - Updated for Batch */}
                    {viewMode === 'loudness_analyzer' && (
                        <div className="bg-slate-800 p-8 rounded-xl border border-slate-700 max-w-5xl mx-auto shadow-2xl flex flex-col items-center">
                            <h2 className="text-2xl font-bold text-cyan-400 mb-6 flex items-center gap-2"><Activity /> 批次音量檢測器</h2>
                            
                            <div className="w-full space-y-6">
                                <div className="border-2 border-dashed border-slate-600 rounded-lg p-8 text-center hover:bg-slate-700/50 transition cursor-pointer relative bg-slate-900/50">
                                    <input 
                                        type="file" 
                                        accept="audio/*, video/mp4, video/x-m4v, .mkv"
                                        multiple 
                                        onChange={handleAnalyzerUpload}
                                        className="absolute inset-0 opacity-0 cursor-pointer"
                                    />
                                    <div className="flex flex-col items-center gap-3">
                                        {isAnalyzing ? (
                                            <RefreshCw size={48} className="text-cyan-400 animate-spin"/>
                                        ) : (
                                            <Upload size={48} className="text-slate-400"/>
                                        )}
                                        <span className="text-slate-300 font-medium">
                                            {isAnalyzing ? "正在分析音訊..." : "點擊或拖曳上傳多個檔案"}
                                        </span>
                                        <span className="text-slate-500 text-xs">支援 WAV, MP3, M4A, OGG, MP4</span>
                                    </div>
                                </div>

                                {analyzerResults.length > 0 && (
                                    <div className="bg-slate-900 rounded-xl border border-slate-600 p-4 animate-in fade-in slide-in-from-bottom-4">
                                        <div className="flex justify-between items-center mb-4 pb-2 border-b border-slate-700">
                                            <div className="flex items-center gap-2">
                                                <FileAudio size={20} className="text-cyan-400"/>
                                                <h3 className="font-bold text-white">檢測報告 ({analyzerResults.length})</h3>
                                            </div>
                                            <div className="flex gap-2">
                                                <button onClick={clearAnalyzerResults} className="text-xs px-3 py-1.5 bg-slate-700 hover:bg-slate-600 rounded text-slate-300">清除列表</button>
                                                <button onClick={exportAnalyzerReport} className="text-xs px-3 py-1.5 bg-emerald-600 hover:bg-emerald-700 rounded text-white font-bold flex items-center gap-1"><Download size={14}/> 匯出 CSV</button>
                                            </div>
                                        </div>
                                        
                                        <div className="overflow-x-auto max-h-[500px] overflow-y-auto custom-scrollbar">
                                            <table className="w-full text-sm text-left">
                                                <thead className="text-xs text-slate-400 uppercase bg-slate-800 sticky top-0 z-10">
                                                    <tr>
                                                        <th className="px-4 py-3">檔名</th>
                                                        <th className="px-4 py-3">時長</th>
                                                        <th className="px-4 py-3 text-center">Peak (dB)</th>
                                                        <th className="px-4 py-3 text-center">RMS (dB)</th>
                                                        <th className="px-4 py-3">狀態</th>
                                                    </tr>
                                                </thead>
                                                <tbody className="divide-y divide-slate-700/50">
                                                    {analyzerResults.map((res) => {
                                                        if (res.status === 'error') {
                                                            return (
                                                                <tr key={res.id} className="bg-red-900/10">
                                                                    <td className="px-4 py-3 text-red-300">{res.filename}</td>
                                                                    <td colSpan="4" className="px-4 py-3 text-red-400 text-xs">{res.errorMsg}</td>
                                                                </tr>
                                                            );
                                                        }

                                                        const peakVal = Number(res.peakDb);
                                                        const rmsVal = Number(res.rmsDb);
                                                        const peakWarning = peakVal > -1; // Red flag if nearly clipping
                                                        const rmsWarning = rmsVal > -14 || rmsVal < -24; // Simple heuristic for too loud/quiet

                                                        return (
                                                            <tr key={res.id} className="hover:bg-slate-800/50">
                                                                <td className="px-4 py-2 font-medium text-slate-200 truncate max-w-[200px]" title={res.filename}>{res.filename}</td>
                                                                <td className="px-4 py-2 text-slate-400 font-mono text-xs">{formatTime(res.duration)}</td>
                                                                <td className={`px-4 py-2 text-center font-mono font-bold ${peakWarning ? 'text-red-500' : 'text-emerald-400'}`}>
                                                                    {res.peakDb}
                                                                </td>
                                                                <td className={`px-4 py-2 text-center font-mono font-bold ${rmsWarning ? 'text-yellow-400' : 'text-blue-400'}`}>
                                                                    {res.rmsDb}
                                                                </td>
                                                                <td className="px-4 py-2">
                                                                    {peakWarning ? <span className="text-[10px] bg-red-900 text-red-200 px-1 rounded">Clip Risk</span> : 
                                                                     rmsWarning ? <span className="text-[10px] bg-yellow-900 text-yellow-200 px-1 rounded">Check Volume</span> : 
                                                                     <span className="text-[10px] bg-emerald-900 text-emerald-200 px-1 rounded">OK</span>}
                                                                </td>
                                                            </tr>
                                                        );
                                                    })}
                                                </tbody>
                                            </table>
                                        </div>
                                        
                                        <div className="mt-4 bg-slate-800/50 p-3 rounded text-xs text-slate-400 flex gap-2 items-start">
                                            <Info size={14} className="shrink-0 mt-0.5"/>
                                            <div>
                                                <p>• 建議 Podcast 人聲平均 (RMS) 落在 <span className="text-white">-16 ~ -18 dB</span>。</p>
                                                <p>• 峰值 (Peak) 絕對不可超過 <span className="text-white">0 dB</span>，建議控制在 <span className="text-white">-1 ~ -3 dB</span> 保留餘裕。</p>
                                            </div>
                                        </div>
                                    </div>
                                )}
                            </div>
                        </div>
                    )}

                    {/* MANUAL INPUT VIEW */}
                    {viewMode === 'manual_input' && (
                        <div className="bg-slate-800 p-8 rounded-xl border border-slate-700 max-w-2xl mx-auto shadow-2xl">
                            <h2 className="text-2xl font-bold text-green-400 mb-6 flex items-center gap-2"><PenTool /> 單句快速輸入與剪輯</h2>
                            
                            <div className="space-y-4">
                                <div>
                                    <label className="block text-sm text-slate-400 mb-1">快速貼上 (格式: 檔名 內容)</label>
                                    <textarea 
                                        value={rawPaste}
                                        onChange={handleRawInputChange}
                                        placeholder="例如：572	yakay inu ku karadrare ini?"
                                        className="w-full bg-slate-900 border border-slate-600 rounded-lg p-3 text-white focus:ring-2 focus:ring-green-500 outline-none font-mono h-24"
                                    />
                                    <p className="text-xs text-slate-500 mt-1">支援 Tab 或 空白分隔。自動解析第一欄為檔名，其餘為內容。</p>
                                </div>

                                <div className="grid grid-cols-2 gap-4">
                                    <div>
                                        <label className="block text-sm text-slate-400 mb-1">目標檔名 (Target Filename)</label>
                                        <input 
                                            type="text" 
                                            value={singleInput.filename}
                                            onChange={(e) => setSingleInput({...singleInput, filename: e.target.value})}
                                            className="w-full bg-slate-900 border border-slate-600 rounded-lg p-3 text-white focus:ring-2 focus:ring-green-500 outline-none"
                                        />
                                    </div>
                                    <div>
                                        <label className="block text-sm text-slate-400 mb-1">內容 (中文/族語)</label>
                                        <input 
                                            type="text" 
                                            value={singleInput.content}
                                            onChange={(e) => setSingleInput({...singleInput, content: e.target.value})}
                                            className="w-full bg-slate-900 border border-slate-600 rounded-lg p-3 text-white focus:ring-2 focus:ring-green-500 outline-none"
                                        />
                                    </div>
                                </div>

                                <div>
                                    <label className="block text-sm text-slate-400 mb-1">上傳音檔</label>
                                    <div className="border-2 border-dashed border-slate-600 rounded-lg p-6 text-center hover:bg-slate-700/50 transition cursor-pointer relative">
                                        <input 
                                            type="file" 
                                            accept="audio/*"
                                            onChange={(e) => setSingleFile(e.target.files[0])}
                                            className="absolute inset-0 opacity-0 cursor-pointer"
                                        />
                                        <div className="flex flex-col items-center gap-2">
                                            {singleFile ? (
                                                <>
                                                    <FileMusic size={32} className="text-green-400"/>
                                                    <span className="text-green-200 font-bold">{singleFile.name}</span>
                                                </>
                                            ) : (
                                                <>
                                                    <Upload size={32} className="text-slate-400"/>
                                                    <span className="text-slate-400">點擊上傳或拖曳檔案至此</span>
                                                </>
                                            )}
                                        </div>
                                    </div>
                                </div>

                                <button 
                                    onClick={handleManualInputSubmit}
                                    disabled={!singleFile || !singleInput.filename || isProcessing}
                                    className="w-full bg-green-600 hover:bg-green-700 disabled:opacity-50 disabled:cursor-not-allowed text-white font-bold py-3 rounded-lg shadow-lg shadow-green-900/20 transition flex items-center justify-center gap-2 mt-4"
                                >
                                    {isProcessing ? <RefreshCw className="animate-spin"/> : <Scissors />}
                                    {isProcessing ? "處理中..." : "開始剪輯"}
                                </button>
                            </div>
                        </div>
                    )}

                    {/* BATCH QC MODE VIEW */}
                    {viewMode === 'batch_qc' && (
                        <div className="grid grid-cols-12 gap-6 h-[800px]">
                             {/* Left: Input */}
                             <div className="col-span-4 bg-slate-800 p-5 rounded-xl border border-slate-700 flex flex-col gap-4">
                                <div>
                                    <h3 className="text-lg font-bold text-white mb-2 flex items-center gap-2"><FileSpreadsheet size={18}/> 1. 貼上 Excel 資料</h3>
                                    <textarea 
                                        value={batchQcTextRaw}
                                        onChange={handleBatchQcTextChange}
                                        placeholder="貼上格式：&#10;目標檔名  內容(族語)&#10;525  yakay inu...&#10;526  kavay..."
                                        className="w-full h-64 bg-slate-900 border border-slate-600 rounded-lg p-3 text-xs text-white font-mono leading-relaxed resize-none focus:ring-2 focus:ring-orange-500 outline-none"
                                    />
                                    <p className="text-xs text-slate-500 mt-2">系統會自動依序對應右側上傳的音檔。</p>
                                </div>
                                <div className="border-t border-slate-700 pt-4">
                                    <h3 className="text-lg font-bold text-white mb-2 flex items-center gap-2"><Upload size={18}/> 2. 批次上傳音檔</h3>
                                    <label className={`flex flex-col items-center justify-center gap-2 bg-slate-700 hover:bg-slate-600 transition p-6 rounded-lg cursor-pointer border-2 border-dashed border-slate-600`}>
                                        <Layers size={24} className="text-orange-400"/>
                                        <span className="text-sm font-bold">選擇多個檔案 (依檔名排序)</span>
                                        <span className="text-xs text-slate-400">已選: {Object.keys(qcAudioFiles).length} 個</span>
                                        <input type="file" accept="audio/*" multiple onChange={handleBatchQcFilesUpload} className="hidden" />
                                    </label>
                                </div>
                                <button onClick={processBatchQcList} className="w-full bg-orange-600 hover:bg-orange-700 text-white font-bold py-3 rounded-lg shadow-lg transition mt-auto flex items-center justify-center gap-2">
                                    <RefreshCw size={18}/> 3. 生成生產線列表
                                </button>
                             </div>

                             {/* Right: List */}
                             <div className="col-span-8 bg-slate-800 p-5 rounded-xl border border-slate-700 flex flex-col overflow-hidden">
                                <div className="flex justify-between items-center mb-4 pb-2 border-b border-slate-700">
                                    <h3 className="text-lg font-bold text-white flex items-center gap-2"><ListChecks size={20}/> 生產線列表</h3>
                                    <div className="flex gap-2">
                                        <button onClick={downloadQcReport} className="text-xs bg-slate-700 hover:bg-slate-600 px-3 py-1.5 rounded text-white flex items-center gap-1"><FileText size={14}/> 匯出報表</button>
                                        <button onClick={downloadQcZip} disabled={isZipping} className="text-xs bg-emerald-600 hover:bg-emerald-700 px-3 py-1.5 rounded text-white flex items-center gap-1 font-bold">{isZipping ? <RefreshCw className="animate-spin" size={14}/> : <Package size={14}/>} 打包出貨 (ZIP)</button>
                                    </div>
                                </div>
                                
                                <div className="overflow-y-auto flex-1 custom-scrollbar">
                                    {qcList.length === 0 ? (
                                        <div className="h-full flex items-center justify-center text-slate-500">等待生成列表...</div>
                                    ) : (
                                        <div className="space-y-2">
                                            {qcList.map(item => (
                                                <div key={item.id} className={`grid grid-cols-12 gap-2 items-center p-3 rounded-lg border ${item.status === 'missing' ? 'bg-red-900/10 border-red-500/30' : 'bg-slate-700/30 border-slate-600'}`}>
                                                    <div className="col-span-1 text-center font-mono text-slate-500 text-xs">{item.id}</div>
                                                    <div className="col-span-4 min-w-0">
                                                        <div className="flex items-center gap-2 mb-1">
                                                            <span className="text-orange-300 font-bold font-mono text-sm">{item.targetName}</span>
                                                            {item.status === 'missing' && <span className="text-[10px] bg-red-900 text-red-200 px-1 rounded">缺檔</span>}
                                                            {item.hasIssue && <span className="text-[10px] bg-red-600 text-white px-1 rounded flex items-center gap-1"><AlertTriangle size={8}/> {item.issueReason}</span>}
                                                        </div>
                                                        <div className="text-slate-400 text-xs truncate" title={item.originalName}>{item.originalName}</div>
                                                    </div>
                                                    <div className="col-span-4 text-sm text-slate-200 truncate" title={item.content}>{item.content}</div>
                                                    <div className="col-span-3 flex justify-end gap-2 items-center">
                                                        {item.status !== 'missing' && (
                                                            <>
                                                                <button onClick={() => toggleQcDenoise(item.id)} className={`p-1.5 rounded transition ${item.isDenoised ? 'bg-purple-600 text-white' : 'text-slate-400 hover:bg-slate-600'}`} title="降噪"><Wand size={14}/></button>
                                                                <button onClick={() => playQcItem(item)} className={`p-1.5 rounded transition ${currentlyPlayingQcId === item.id ? 'bg-blue-500 text-white animate-pulse' : 'text-slate-200 hover:bg-blue-600'}`} title="試聽"><Play size={14}/></button>
                                                                
                                                                <div className="relative">
                                                                    <button onClick={() => setFlagMenuId(flagMenuId === item.id ? null : item.id)} className={`p-1.5 rounded transition ${item.hasIssue ? 'bg-red-600 text-white' : 'text-slate-400 hover:bg-slate-600'}`}><Flag size={14}/></button>
                                                                    {flagMenuId === item.id && (
                                                                        <div className="absolute right-0 top-full mt-1 z-50 bg-slate-800 border border-slate-600 rounded-lg shadow-xl p-1 flex flex-col gap-1 w-32">
                                                                            {['族語錯誤', '音檔錯誤', '不一致'].map(r => (
                                                                                <button key={r} onClick={() => setQcIssue(item.id, r)} className="text-left px-2 py-1 text-xs hover:bg-slate-700 text-slate-200">{r}</button>
                                                                            ))}
                                                                            {item.hasIssue && <button onClick={() => clearQcIssue(item.id)} className="text-left px-2 py-1 text-xs hover:bg-red-900/50 text-red-300 border-t border-slate-700">取消標記</button>}
                                                                        </div>
                                                                    )}
                                                                </div>
                                                            </>
                                                        )}
                                                    </div>
                                                </div>
                                            ))}
                                        </div>
                                    )}
                                </div>
                             </div>
                        </div>
                    )}

                    {/* WAVEFORM VISUALIZER - Toggleable */}
                    {viewMode === 'splitter' && (
                        <div className="bg-slate-800 p-4 rounded-xl border border-slate-700 shadow-lg">
                            <div className="flex justify-between items-center mb-4">
                                <div className="flex items-center gap-4">
                                    <button 
                                        onClick={() => setShowBigWaveform(!showBigWaveform)}
                                        className="flex items-center gap-2 text-sm font-semibold text-slate-300 hover:text-white transition"
                                    >
                                        {showBigWaveform ? <Eye size={18} className="text-blue-400" /> : <EyeOff size={18} />}
                                        波形預覽 ({fileName})
                                    </button>
                                </div>
                                <div className="flex items-center gap-4 bg-slate-900/50 p-2 rounded-lg">
                                    {showBigWaveform && (
                                        <>
                                            <div className="flex items-center gap-2"><ZoomIn size={14} className="text-slate-400"/><input type="range" min="1" max="20" step="0.5" value={zoomLevel} onChange={(e) => setZoomLevel(Number(e.target.value))} className="w-24 h-2 bg-slate-600 rounded-lg accent-blue-500 cursor-pointer"/></div>
                                            <div className="w-px h-4 bg-slate-700"></div>
                                            <div className="flex items-center gap-2"><Activity size={14} className="text-slate-400"/><input type="range" min="1" max="10" step="0.5" value={ampScale} onChange={(e) => setAmpScale(Number(e.target.value))} className="w-24 h-2 bg-slate-600 rounded-lg accent-purple-500 cursor-pointer"/></div>
                                        </>
                                    )}
                                </div>
                            </div>
                            
                            {showBigWaveform && (
                                <>
                                    {/* Main Canvas Scrollable */}
                                    <div 
                                        ref={containerRef} 
                                        onScroll={handleContainerScroll}
                                        className="relative w-full h-64 bg-slate-900 rounded-lg overflow-x-auto overflow-y-hidden border border-slate-700 custom-scrollbar select-none group"
                                    >
                                        <canvas 
                                            ref={canvasRef} 
                                            height={256} 
                                            className="h-full" 
                                            onMouseDown={handleCanvasMouseDown}
                                            onMouseMove={handleCanvasMouseMove}
                                            onMouseUp={handleCanvasMouseUp}
                                            onMouseLeave={handleCanvasMouseLeave}
                                        />
                                        {!audioBuffer && <div className="absolute inset-0 flex flex-col items-center justify-center text-slate-500 gap-2"><Upload size={32} className="opacity-50"/><p>請上傳音檔以開始編輯</p></div>}
                                    </div>

                                    {/* Navigation Minimap */}
                                    {audioBuffer && (
                                        <div className="mt-2 relative h-12 w-full bg-slate-900 rounded border border-slate-700 overflow-hidden cursor-pointer"
                                             onMouseDown={handleMinimapMouseDown}
                                             onMouseMove={handleMinimapMouseMove}
                                             onMouseUp={() => setDragTarget(null)}
                                             onMouseLeave={() => setDragTarget(null)}
                                        >
                                            <canvas ref={minimapRef} width={containerRef.current?.clientWidth || 800} height={48} className="w-full h-full" />
                                        </div>
                                    )}

                                    {/* Metadata / Player Info Bar */}
                                    <div className="flex justify-between items-start mt-3">
                                        <div className="text-xs text-slate-500 font-mono flex flex-col justify-center">
                                            <span>{audioBuffer ? formatTime(currentTime) : '00:00:00.000'}</span>
                                            <span>{audioBuffer ? formatTime(audioBuffer.duration) : '--:--:--.---'}</span>
                                        </div>
                                        
                                        {/* Active Display Area */}
                                        {activeDisplay && (
                                            <div className="flex-1 mx-6 bg-slate-900/80 border border-slate-600 rounded-lg p-2 flex items-center gap-3 animate-in fade-in slide-in-from-bottom-2">
                                                <MessageSquare size={20} className="text-blue-400 shrink-0" />
                                                <div className="flex flex-col min-w-0">
                                                    <span className="text-sm font-bold text-white truncate">{activeDisplay.name}</span>
                                                    {activeDisplay.secondary && <span className="text-xl text-emerald-400 font-mono truncate font-bold">{activeDisplay.secondary}</span>}
                                                </div>
                                            </div>
                                        )}

                                        <div className="flex justify-center gap-4 text-xs text-slate-500 mt-1 flex-col items-end">
                                            <span className="flex items-center gap-1"><MousePointer2 size={12}/> 空白處拖曳可框選建立新標記</span>
                                            <span className="flex items-center gap-1"><Move size={12}/> 紅色區塊點擊播放 / 拖曳移動</span>
                                        </div>
                                    </div>
                                </>
                            )}
                        </div>
                    )}

                    {viewMode === 'merger' && (
                        <div className="bg-slate-800 p-6 rounded-xl border border-slate-700 min-h-[500px] flex flex-col gap-6">
                            <div className="flex flex-col md:flex-row justify-between items-start md:items-center gap-4">
                                <div><h2 className="text-xl font-bold flex items-center gap-2 text-purple-300"><Layers size={24} /> 批次合併 (Batch Merger)</h2><p className="text-slate-400 text-sm mt-1">上傳多個音檔，系統將依據 CSV 腳本順序合併。自動偵測並切分一檔多句的情況。</p></div>
                                <div className="flex gap-4 items-center"><label className={`flex items-center gap-2 bg-purple-600 hover:bg-purple-700 transition px-4 py-2 rounded-lg cursor-pointer font-bold ${isProcessing ? 'opacity-50 cursor-not-allowed' : ''}`}><Upload size={18} /> <span>選擇多個檔案</span><input type="file" accept="audio/*" multiple onChange={handleStagedFilesUpload} disabled={isProcessing} className="hidden" /></label></div>
                            </div>
                            <div className="flex-1 bg-slate-900/50 rounded-lg border border-slate-700 overflow-hidden">
                                {uniqueFileNames.length === 0 ? (<div className="flex flex-col items-center justify-center h-64 text-slate-500"><FileSpreadsheet size={48} className="opacity-20 mb-4" /><p>請先載入 CSV 腳本以顯示列表</p></div>) : (
                                    <div className="overflow-y-auto max-h-[600px]">
                                        <table className="w-full text-sm text-left"><thead className="text-xs text-slate-400 uppercase bg-slate-800 sticky top-0"><tr><th className="px-4 py-3">#</th><th className="px-4 py-3">原始檔名 (CSV Source)</th><th className="px-4 py-3">狀態</th><th className="px-4 py-3 text-right">操作</th></tr></thead><tbody className="divide-y divide-slate-700/50">
                                            {uniqueFileNames.map((fname, idx) => {
                                                const isMatched = !!stagedFiles[fname];
                                                return (<tr key={idx} className={`hover:bg-slate-700/30 ${isMatched ? 'bg-slate-800/50' : ''}`}><td className="px-4 py-2 font-mono text-slate-500">{idx + 1}</td><td className="px-4 py-2 text-slate-300 font-medium">{fname}</td><td className="px-4 py-2">{isMatched ? (<span className="inline-flex items-center gap-1 text-emerald-400 text-xs"><CheckCircle2 size={12}/> Ready</span>) : (<span className="inline-flex items-center gap-1 text-slate-500 text-xs"><XCircle size={12}/> Missing</span>)}</td><td className="px-4 py-2 text-right">{isMatched && (<button onClick={() => removeStagedFile(fname)} className="text-slate-500 hover:text-red-400 p-1" title="移除音檔"><Trash2 size={14}/></button>)}</td></tr>)
                                            })}
                                        </tbody></table>
                                    </div>
                                )}
                            </div>
                            <div className="flex justify-end pt-4 border-t border-slate-700"><button onClick={handleMergeAndLoad} disabled={uniqueFileNames.length === 0 || isProcessing} className="flex items-center gap-2 px-6 py-3 bg-emerald-600 hover:bg-emerald-700 disabled:opacity-50 disabled:cursor-not-allowed rounded-lg font-bold text-white shadow-lg shadow-emerald-900/20 transition">{isProcessing ? <RefreshCw className="animate-spin" size={20}/> : <Merge size={20} />}<span>{isProcessing ? '處理中...' : '開始合併並自動切分'}</span>{!isProcessing && <ArrowRight size={20} />}</button></div>
                        </div>
                    )}
                </div>
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
